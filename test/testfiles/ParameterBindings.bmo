// SPDX-License-Identifier: MIT
// Test file for parameter binding expressions

//! base 0.1.0
package 'ParameterBindings'
  model 'ParameterBindings'
    // Base parameters with const bindings
    parameter Real 'base_value' = 10.0;
    parameter Real 'scale' = 2.0;
    
    // Parameter with const binding expression
    parameter Real 'const_computed' = 5.0;
    
    // Parameter with non-const binding expression
    parameter Real 'scaled_value' = 'base_value' * 'scale';
    
    // Parameter with non-const binding and const min/max
    parameter Real 'bounded_value'(min = 0.0, max = 100.0) = 'base_value' + 'scale';
    
    // Parameter with non-const binding and non-const min
    parameter Real 'dynamic_bounded'(min = 'base_value', start= 'base_value' * 3.0);

    // Parameter with non-const max only
    parameter Real 'dynamic_max'(max = 'base_value' * 10.0) = 50.0;

    // Parameter with both non-const min and max
    parameter Real 'dynamic_both'(min = 'base_value', max = 'base_value' * 5.0) = 25.0;

    // Parameter with const min and non-const max
    parameter Real 'mixed_bounds_1'(min = 0.0, max = 'base_value' * 2.0) = 10.0;

    // Parameter with non-const min and const max
    parameter Real 'mixed_bounds_2'(min = 'base_value' / 2.0, max = 200.0) = 100.0;

    // Parameter with const min/max (should stay in modelDescription only)
    parameter Real 'const_bounds'(min = -100.0, max = 100.0) = 0.0;

    // Array parameter with non-const binding
    parameter Real 'array_param[1]' = 'base_value';
    parameter Real 'array_param[2]' = 'base_value' * 2.0;
    parameter Real 'array_param[3]' = 'base_value' * 3.0;

    // State variables that use the parameters
    Real 'x'(start = scaled_value);
    Real 'y'(start = 0.0);
    Real 'z'(start = 0.0);
    Real 'w'(start = 0.0);

  equation
    der('x') = 'scaled_value' * 'x';
    der('y') = 'bounded_value' - 'const_computed';
    der('z') = 'dynamic_bounded' + 'array_param[1]' + 'array_param[2]' + 'array_param[3]';
    der('w') = 'dynamic_max' + 'dynamic_both' + 'mixed_bounds_1' + 'mixed_bounds_2' + 'const_bounds';
  end 'ParameterBindings';
end 'ParameterBindings';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     """
//     Compute expected outputs for ParameterBindings.
//
//     Equations:
//       der('x') = 'scaled_value' * 'x'
//       der('y') = 'bounded_value' - 'const_computed'
//       der('z') = 'dynamic_bounded' + 'array_param[1]' + 'array_param[2]' + 'array_param[3]'
//       der('w') = 'dynamic_max' + 'dynamic_both' + 'mixed_bounds_1' + 'mixed_bounds_2' + 'const_bounds'
//
//     Parameter bindings:
//       scaled_value = base_value * scale
//       bounded_value = base_value + scale
//       array_param[1] = base_value
//       array_param[2] = base_value * 2.0
//       array_param[3] = base_value * 3.0
//     """
//     import numpy as np
//     outputs = {}
//
//     # Extract base parameters
//     base_value = inputs['base_value']
//     scale = inputs['scale']
//     const_computed = inputs['const_computed']
//     dynamic_bounded = inputs['dynamic_bounded']
//     dynamic_max = inputs['dynamic_max']
//     dynamic_both = inputs['dynamic_both']
//     mixed_bounds_1 = inputs['mixed_bounds_1']
//     mixed_bounds_2 = inputs['mixed_bounds_2']
//     const_bounds = inputs['const_bounds']
//
//     # Compute derived parameters (parameter bindings)
//     scaled_value = base_value * scale
//     bounded_value = base_value + scale
//     array_param_1 = base_value
//     array_param_2 = base_value * 2.0
//     array_param_3 = base_value * 3.0
//
//     # Extract state variables and derivatives
//     x = inputs['x']
//     y = inputs['y']
//     z = inputs['z']
//     w = inputs['w']
//     der_x = inputs["der('x')"]
//     der_y = inputs["der('y')"]
//     der_z = inputs["der('z')"]
//     der_w = inputs["der('w')"]
//
//     # Compute equation residuals (LHS - RHS = 0)
//     # Equation 0: der('x') = 'scaled_value' * 'x'
//     outputs['eq[0]'] = np.array(der_x - scaled_value * x)
//
//     # Equation 1: der('y') = 'bounded_value' - 'const_computed'
//     outputs['eq[1]'] = np.array(der_y - (bounded_value - const_computed))
//
//     # Equation 2: der('z') = 'dynamic_bounded' + 'array_param[1]' + 'array_param[2]' + 'array_param[3]'
//     outputs['eq[2]'] = np.array(der_z - (dynamic_bounded + array_param_1 + array_param_2 + array_param_3))
//
//     # Equation 3: der('w') = 'dynamic_max' + 'dynamic_both' + 'mixed_bounds_1' + 'mixed_bounds_2' + 'const_bounds'
//     outputs['eq[3]'] = np.array(der_w - (dynamic_max + dynamic_both + mixed_bounds_1 + mixed_bounds_2 + const_bounds))
//
//     # Start values (from start attributes)
//     outputs['start[0]'] = np.array(scaled_value)  # x.start = scaled_value
//     outputs['start[1]'] = np.array(0.0)  # y.start = 0.0
//     outputs['start[2]'] = np.array(0.0)  # z.start = 0.0
//     outputs['start[3]'] = np.array(0.0)  # w.start = 0.0
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: Default parameters with zero states and derivatives
// import numpy as np
// base_value = np.array(10.0)
// scale = np.array(2.0)
// {
//   "base_value": base_value,
//   "scale": scale,
//   "const_computed": np.array(5.0),
//   "dynamic_bounded": np.array(30.0),
//   "dynamic_max": np.array(50.0),
//   "dynamic_both": np.array(25.0),
//   "mixed_bounds_1": np.array(10.0),
//   "mixed_bounds_2": np.array(100.0),
//   "const_bounds": np.array(0.0),
//   "x": np.array(0.0),
//   "y": np.array(0.0),
//   "z": np.array(0.0),
//   "w": np.array(0.0),
//   "der('x')": np.array(0.0),
//   "der('y')": np.array(0.0),
//   "der('z')": np.array(0.0),
//   "der('w')": np.array(0.0)
// }
//
// @onnx-test-case
// # Test case 2: Non-zero states with computed derivatives
// import numpy as np
// base_value = np.array(10.0)
// scale = np.array(2.0)
// x = np.array(1.5)
// scaled_value = base_value * scale
// {
//   "base_value": base_value,
//   "scale": scale,
//   "const_computed": np.array(5.0),
//   "dynamic_bounded": np.array(30.0),
//   "dynamic_max": np.array(50.0),
//   "dynamic_both": np.array(25.0),
//   "mixed_bounds_1": np.array(10.0),
//   "mixed_bounds_2": np.array(100.0),
//   "const_bounds": np.array(0.0),
//   "x": x,
//   "y": np.array(3.0),
//   "z": np.array(5.0),
//   "w": np.array(10.0),
//   "der('x')": np.array(scaled_value * x),
//   "der('y')": np.array(7.0),
//   "der('z')": np.array(90.0),
//   "der('w')": np.array(185.0)
// }
//
// @onnx-test-case
// # Test case 3: Modified base parameters with different bindings
// import numpy as np
// base_value = np.array(5.0)
// scale = np.array(3.0)
// x = np.array(2.0)
// scaled_value = base_value * scale
// {
//   "base_value": base_value,
//   "scale": scale,
//   "const_computed": np.array(2.0),
//   "dynamic_bounded": np.array(15.0),
//   "dynamic_max": np.array(25.0),
//   "dynamic_both": np.array(12.5),
//   "mixed_bounds_1": np.array(5.0),
//   "mixed_bounds_2": np.array(50.0),
//   "const_bounds": np.array(1.0),
//   "x": x,
//   "y": np.array(1.0),
//   "z": np.array(2.5),
//   "w": np.array(5.0),
//   "der('x')": np.array(scaled_value * x),
//   "der('y')": np.array(6.0),
//   "der('z')": np.array(55.0),
//   "der('w')": np.array(93.5)
// }
//
