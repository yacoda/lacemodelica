// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Joris Gillis, YACODA

//! base 0.1.0
package 'MatrixState'
  model 'MatrixState' "Test model with matrix-sized state (3x4)"
    parameter Real 'alpha' = 0.5 "Decay coefficient";

    Real 'A'[3, 4](fixed = true, start = 0.0) "State matrix";
    Real 'y' "Output";

  equation
    der('A') = -'alpha' * 'A';
    'y' = 'A'[1, 1] + 'A'[2, 2] + 'A'[3, 3];

  end 'MatrixState';
end 'MatrixState';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs (already numpy arrays)
//     alpha = inputs['alpha']
//     A = inputs['A']  # 3x4 matrix
//     der_A = inputs["der('A')"]  # 3x4 matrix
//     y = inputs['y']  # scalar
//
//     # Equation 0: der(A) = -alpha * A => der(A) + alpha * A = 0
//     outputs['eq[0]'] = der_A + alpha * A
//
//     # Equation 1: y = A[1,1] + A[2,2] + A[3,3] => y - (A[1,1] + A[2,2] + A[3,3]) = 0
//     # Note: Modelica uses 1-based indexing, Python uses 0-based
//     diagonal_sum = A[0, 0] + A[1, 1] + A[2, 2]
//     outputs['eq[1]'] = y - diagonal_sum
//
//     # Initial values (start attributes)
//     outputs['start[0]'] = np.zeros((3, 4))  # A's initial value
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: Random matrix (seed 42)
// import numpy as np
// rng = np.random.RandomState(42)
// alpha = 0.5
// A = rng.uniform(-1.0, 1.0, (3, 4))
// y = A[0, 0] + A[1, 1] + A[2, 2]
// der_A = -alpha * A
// {
//   "alpha": np.array(0.5),
//   "A": A,
//   "y": np.array(y),
//   "der('A')": der_A
// }
//
// @onnx-test-case
// # Test case 2: Random matrix (seed 123)
// import numpy as np
// rng = np.random.RandomState(123)
// alpha = 0.5
// A = rng.uniform(-2.0, 2.0, (3, 4))
// y = A[0, 0] + A[1, 1] + A[2, 2]
// der_A = -alpha * A
// {
//   "alpha": np.array(0.5),
//   "A": A,
//   "y": np.array(y),
//   "der('A')": der_A
// }
//
// @onnx-test-case
// # Test case 3: Random matrix (seed 999)
// import numpy as np
// rng = np.random.RandomState(999)
// alpha = 0.5
// A = rng.uniform(0.0, 3.0, (3, 4))
// y = A[0, 0] + A[1, 1] + A[2, 2]
// der_A = -alpha * A
// {
//   "alpha": np.array(0.5),
//   "A": A,
//   "y": np.array(y),
//   "der('A')": der_A
// }
