// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Joris Gillis, YACODA

//! base 0.1.0
package 'ForLoopNested'
  model 'ForLoopNested' "Test model with nested for loops"
    parameter Real 'alpha' = 0.5 "Decay coefficient";
    parameter Real 'beta' = 1.0 "Coupling coefficient";

    Real 'A'[3, 4](fixed = true, start = 0.0) "2D state matrix";
    Real 'x'[3](fixed = true, start = 0.0) "State vector";
    Real 'y' "Sum variable";

  equation
    // Nested for-loops: outer loop has equation, then inner loop
    for i in 1:3 loop
      // Equation in outer loop first
      der('x'[i]) = -'alpha' * 'x'[i];

      // Then inner nested loop
      for j in 1:4 loop
        der('A'[i, j]) = 'beta' * 'A'[i, j] + 'x'[i];
      end for;
    end for;

    // Variable not in loop body
    'y' = 'x'[1] + 'x'[2] + 'x'[3];

  end 'ForLoopNested';
end 'ForLoopNested';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs
//     A = inputs['A']  # shape (3, 4)
//     x = inputs['x']  # shape (3,)
//     y = inputs['y']
//     alpha = inputs['alpha']
//     beta = inputs['beta']
//     der_A = inputs["der(A)"]  # shape (3, 4)
//     der_x = inputs["der(x)"]  # shape (3,)
//
//     # Outer loop i in 1:3
//     # First equation in outer loop: der(x[i]) = -alpha * x[i]
//     outputs['eq[0]'] = np.array([der_x[i] - (-alpha * x[i]) for i in range(3)])
//
//     # Inner nested loop j in 1:4 for each i in 1:3
//     # der(A[i][j]) = beta * A[i][j] + x[i]
//     # This creates a 3x4 array of residuals
//     residuals = np.zeros((3, 4))
//     for i in range(3):
//         for j in range(4):
//             residuals[i, j] = der_A[i, j] - (beta * A[i, j] + x[i])
//     outputs['eq[1]'] = residuals
//
//     # y equation
//     outputs['eq[2]'] = y - (x[0] + x[1] + x[2])
//
//     # Initial equations
//     for i in range(3):
//         outputs[f'init_eq[{i}]'] = x[i] - 0.0
//     for i in range(3):
//         for j in range(4):
//             outputs[f'init_eq[{3 + i*4 + j}]'] = A[i, j] - 0.0
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: Initial conditions
// import numpy as np
// A = np.zeros((3, 4))
// x = np.array([0.0, 0.0, 0.0])
// alpha = 0.5
// beta = 1.0
// y = 0.0
// der_x = np.array([-alpha * x[i] for i in range(3)])
// der_A = np.array([[beta * A[i, j] + x[i] for j in range(4)] for i in range(3)])
// {
//   "A": A,
//   "x": x,
//   "y": np.array(y),
//   "alpha": np.array(alpha),
//   "beta": np.array(beta),
//   "der(A)": der_A,
//   "der(x)": der_x
// }
//
// @onnx-test-case
// # Test case 2: Non-zero state
// import numpy as np
// A = np.array([[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [9.0, 10.0, 11.0, 12.0]])
// x = np.array([1.0, 2.0, 3.0])
// alpha = 0.5
// beta = 1.0
// y = 6.0
// der_x = np.array([-alpha * x[i] for i in range(3)])
// der_A = np.array([[beta * A[i, j] + x[i] for j in range(4)] for i in range(3)])
// {
//   "A": A,
//   "x": x,
//   "y": np.array(y),
//   "alpha": np.array(alpha),
//   "beta": np.array(beta),
//   "der(A)": der_A,
//   "der(x)": der_x
// }
//
// @onnx-test-case
// # Test case 3: Different parameters
// import numpy as np
// A = np.array([[0.5, 1.5, 2.5, 3.5], [4.5, 5.5, 6.5, 7.5], [8.5, 9.5, 10.5, 11.5]])
// x = np.array([0.5, 1.5, 2.5])
// alpha = 1.0
// beta = 0.5
// y = 4.5
// der_x = np.array([-alpha * x[i] for i in range(3)])
// der_A = np.array([[beta * A[i, j] + x[i] for j in range(4)] for i in range(3)])
// {
//   "A": A,
//   "x": x,
//   "y": np.array(y),
//   "alpha": np.array(alpha),
//   "beta": np.array(beta),
//   "der(A)": der_A,
//   "der(x)": der_x
// }
//
