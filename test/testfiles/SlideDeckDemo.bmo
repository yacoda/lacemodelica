// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Joris Gillis, YACODA

//! base 0.1.0
package 'SlideDeckDemo'
  pure function 'foo'
    input Real 'x';
    output Real 'y';
  algorithm
    'y' := sin('x');
    'y' := 2*'y';
  end 'foo';

  model 'SlideDeckDemo'
    parameter Real 'p' = 2.0;
    Real 'x'[3] = 'p' * {1.0, 2.0, 3.0};
    Real 'y';
  equation
    der('x') = 'x';
    'y' = sum('foo'('p' * 'x'[i]) for i in 1:3);
  end 'SlideDeckDemo';
end 'SlideDeckDemo';

// @onnx-test-reference
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//     p = inputs['p']
//     x = inputs['x']
//     der_x = inputs['der(x)']
//     # der(x) = x
//     outputs['eq[0]'] = der_x - x
//     # y = sum(foo(p * x[i]) for i in 1:3) where foo(x) = 2*sin(x)
//     outputs['eq[1]'] = inputs['y'] - np.sum(2 * np.sin(p * x))
//     # start = p * {1, 2, 3}
//     outputs['start[1]'] = p * np.array([1.0, 2.0, 3.0])
//     return outputs
//
// @onnx-test-case
// import numpy as np
// p = 2.0
// x = np.array([2.0, 4.0, 6.0])
// der_x = x  # der(x) = x
// y = np.sum(2 * np.sin(p * x))
// {
//   "p": np.array(p),
//   "x": x,
//   "der(x)": der_x,
//   "y": np.array(y)
// }
//
// @onnx-test-case
// import numpy as np
// p = 2.0
// x = np.array([1.0, 1.0, 1.0])
// der_x = x  # der(x) = x
// y = np.sum(2 * np.sin(p * x))
// {
//   "p": np.array(p),
//   "x": x,
//   "der(x)": der_x,
//   "y": np.array(y)
// }
