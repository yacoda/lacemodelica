//! base 0.1.0
package 'ArithmeticOps'
  model 'ArithmeticOps' "Various arithmetic operations"
    Real 'x'(start = 1.0);
    Real 'squared';
    Real 'cubed';
    Real 'sqrt_approx';
    Real 'complex';
  equation
    der('x') = 0.1;
    'squared' = 'x' ^ 2;
    'cubed' = 'x' ^ 3;
    'sqrt_approx' = 'x' ^ 0.5;
    'complex' = (('x' + 1.0) ^ 2) / (('x' - 0.5) ^ 2 + 1.0);
  end 'ArithmeticOps';
end 'ArithmeticOps';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs (already numpy scalars)
//     x = inputs['x']
//     der_x = inputs["der('x')"]
//     squared = inputs['squared']
//     cubed = inputs['cubed']
//     sqrt_approx = inputs['sqrt_approx']
//     complex_val = inputs['complex']
//
//     # Compute equation residuals (LHS - RHS = 0)
//     outputs['eq[0]'] = der_x - 0.1
//     outputs['eq[1]'] = squared - (x ** 2)
//     outputs['eq[2]'] = cubed - (x ** 3)
//     outputs['eq[3]'] = sqrt_approx - (x ** 0.5)
//
//     expected_complex = ((x + 1.0) ** 2) / (((x - 0.5) ** 2) + 1.0)
//     outputs['eq[4]'] = complex_val - expected_complex
//
//     # Initial value
//     outputs['start[0]'] = np.array(1.0)
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: Random value (seed 42)
// import numpy as np
// rng = np.random.RandomState(42)
// x = rng.uniform(1.0, 5.0)
// der_x = 0.1
// squared = x ** 2
// cubed = x ** 3
// sqrt_approx = x ** 0.5
// complex_val = ((x + 1.0) ** 2) / (((x - 0.5) ** 2) + 1.0)
// {
//   "x": np.array(x),
//   "der('x')": np.array(der_x),
//   "squared": np.array(squared),
//   "cubed": np.array(cubed),
//   "sqrt_approx": np.array(sqrt_approx),
//   "complex": np.array(complex_val)
// }
//
// @onnx-test-case
// # Test case 2: Random value (seed 123)
// import numpy as np
// rng = np.random.RandomState(123)
// x = rng.uniform(0.5, 10.0)
// der_x = 0.1
// squared = x ** 2
// cubed = x ** 3
// sqrt_approx = x ** 0.5
// complex_val = ((x + 1.0) ** 2) / (((x - 0.5) ** 2) + 1.0)
// {
//   "x": np.array(x),
//   "der('x')": np.array(der_x),
//   "squared": np.array(squared),
//   "cubed": np.array(cubed),
//   "sqrt_approx": np.array(sqrt_approx),
//   "complex": np.array(complex_val)
// }
//
// @onnx-test-case
// # Test case 3: Random value (seed 999)
// import numpy as np
// rng = np.random.RandomState(999)
// x = rng.uniform(2.0, 8.0)
// der_x = 0.1
// squared = x ** 2
// cubed = x ** 3
// sqrt_approx = x ** 0.5
// complex_val = ((x + 1.0) ** 2) / (((x - 0.5) ** 2) + 1.0)
// {
//   "x": np.array(x),
//   "der('x')": np.array(der_x),
//   "squared": np.array(squared),
//   "cubed": np.array(cubed),
//   "sqrt_approx": np.array(sqrt_approx),
//   "complex": np.array(complex_val)
// }
