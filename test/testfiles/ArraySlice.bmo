// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Joris Gillis, YACODA

//! base 0.1.0
package 'ArraySlice'
  // Function using full slice to copy entire array
  pure function 'copyArray' "Copy array using full slice"
    input Real 'arr'[4];
    output Real 'result'[4];
  algorithm
    'result'[:] := 'arr'[:];
  end 'copyArray';

  // Function using range slice to extract subarray
  pure function 'extractMiddle' "Extract middle elements using range slice"
    input Real 'arr'[6];
    output Real 'result'[3];
  algorithm
    'result'[:] := 'arr'[2:4];  // Extract elements 2, 3, 4
  end 'extractMiddle';

  // Function using slice on left-hand side for partial assignment
  pure function 'assignPartial' "Assign to partial array using slice"
    input Real 'arr'[4];
    input Real 'val';
    output Real 'result'[4];
  algorithm
    'result'[:] := 'arr'[:];
    'result'[2:3] := {'val', 'val' * 2};  // Assign to elements 2 and 3
  end 'assignPartial';

  // Function combining slice read with element-wise operation
  pure function 'scaleSlice' "Scale a slice of an array"
    input Real 'arr'[5];
    input Real 'factor';
    output Real 'result'[3];
  algorithm
    'result'[:] := 'factor' * 'arr'[1:3];
  end 'scaleSlice';

  model 'ArraySlice' "Model testing array slice operations"
    parameter Real 'a'[4] = {1.0, 2.0, 3.0, 4.0};
    parameter Real 'b'[6] = {10.0, 20.0, 30.0, 40.0, 50.0, 60.0};
    parameter Real 'c'[5] = {1.0, 2.0, 3.0, 4.0, 5.0};
    Real 'x'(start = 0.0);
    Real 'y1'[4];
    Real 'y2'[3];
    Real 'y3'[4];
    Real 'y4'[3];
  equation
    der('x') = 0.1;
    'y1' = 'copyArray'('a');
    'y2' = 'extractMiddle'('b');
    'y3' = 'assignPartial'('a', 5.0);
    'y4' = 'scaleSlice'('c', 2.0);
  end 'ArraySlice';
end 'ArraySlice';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs
//     x = inputs['x']
//     der_x = inputs["der(x)"]
//     y1 = inputs['y1']
//     y2 = inputs['y2']
//     y3 = inputs['y3']
//     y4 = inputs['y4']
//     a = inputs['a']
//     b = inputs['b']
//     c = inputs['c']
//
//     # Equation 0: der(x) = 0.1
//     outputs['eq[0]'] = der_x - 0.1
//
//     # Equation 1: y1 = copyArray(a)
//     # Full slice copy: result[:] = arr[:]
//     result1 = np.copy(a)
//     outputs['eq[1]'] = y1 - result1
//
//     # Equation 2: y2 = extractMiddle(b)
//     # Range slice: result[:] = arr[1:4] (0-based indices for 2:4 in 1-based)
//     result2 = b[1:4]  # Elements at indices 1, 2, 3 (values 20, 30, 40)
//     outputs['eq[2]'] = y2 - result2
//
//     # Equation 3: y3 = assignPartial(a, 5.0)
//     # Partial assignment: result[1:3] = {val, val*2}
//     result3 = np.copy(a)
//     result3[1:3] = [5.0, 10.0]  # Assign to indices 1 and 2
//     outputs['eq[3]'] = y3 - result3
//
//     # Equation 4: y4 = scaleSlice(c, 2.0)
//     # Scale slice: result[:] = factor * arr[0:3]
//     result4 = 2.0 * c[0:3]
//     outputs['eq[4]'] = y4 - result4
//
//     # Initial values for parameters a, b, c (model defaults, not inputs)
//     outputs['start[0]'] = np.array([1.0, 2.0, 3.0, 4.0])  # Parameter a[4] default
//     outputs['start[1]'] = np.array([10.0, 20.0, 30.0, 40.0, 50.0, 60.0])  # Parameter b[6] default
//     outputs['start[2]'] = np.array([1.0, 2.0, 3.0, 4.0, 5.0])  # Parameter c[5] default
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: Default parameters
// import numpy as np
// x = 0.0
// der_x = 0.1
// a = np.array([1.0, 2.0, 3.0, 4.0])
// b = np.array([10.0, 20.0, 30.0, 40.0, 50.0, 60.0])
// c = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
// y1 = np.array([1.0, 2.0, 3.0, 4.0])
// y2 = np.array([20.0, 30.0, 40.0])
// y3 = np.array([1.0, 5.0, 10.0, 4.0])
// y4 = np.array([2.0, 4.0, 6.0])
// {
//   "x": np.array(x),
//   "der(x)": np.array(der_x),
//   "y1": y1,
//   "y2": y2,
//   "y3": y3,
//   "y4": y4,
//   "a": a,
//   "b": b,
//   "c": c
// }
//
// @onnx-test-case
// # Test case 2: Different values
// import numpy as np
// x = 1.0
// der_x = 0.1
// a = np.array([0.5, 1.5, 2.5, 3.5])
// b = np.array([5.0, 15.0, 25.0, 35.0, 45.0, 55.0])
// c = np.array([0.0, 1.0, 2.0, 3.0, 4.0])
// y1 = np.array([0.5, 1.5, 2.5, 3.5])
// y2 = np.array([15.0, 25.0, 35.0])
// y3 = np.array([0.5, 5.0, 10.0, 3.5])
// y4 = np.array([0.0, 2.0, 4.0])
// {
//   "x": np.array(x),
//   "der(x)": np.array(der_x),
//   "y1": y1,
//   "y2": y2,
//   "y3": y3,
//   "y4": y4,
//   "a": a,
//   "b": b,
//   "c": c
// }
//
