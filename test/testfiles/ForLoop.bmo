// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Joris Gillis, YACODA

//! base 0.1.0
package 'ForLoop'
  model 'ForLoop' "Test model with for loop in equations"
    parameter Real 'alpha' = 0.5 "Decay coefficient";

    Real 'x'[3](fixed = true, start = 0.0) "State vector";
    Real 'z'[3](fixed = true, start = 0.0) "State vector";
    Real 'y' "Output";

  equation
    for i in 1:3 loop
      der('x'[i]) = -'alpha' * 'x'[i];
      der('z'[i]) = 'z'[i] + 'x'[i];
    end for;
    'y' = 'x'[1] + 'x'[2] + 'x'[3];

  end 'ForLoop';
end 'ForLoop';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs (arrays)
//     x = inputs['x']
//     z = inputs['z']
//     y = inputs['y']
//     alpha = inputs['alpha']
//     der_x = inputs["der('x')"]
//     der_z = inputs["der('z')"]
//
//     # For loop equation 1: der(x[i]) = -alpha * x[i] for i in 1:3
//     # Loop outputs scan array of residuals
//     outputs['eq[0]'] = np.array([der_x[i] - (-alpha * x[i]) for i in range(3)])
//
//     # For loop equation 2: der(z[i]) = z[i] + x[i] for i in 1:3
//     outputs['eq[1]'] = np.array([der_z[i] - (z[i] + x[i]) for i in range(3)])
//
//     # Equation 2: y = x[1] + x[2] + x[3] (0-indexed: x[0] + x[1] + x[2])
//     outputs['eq[2]'] = y - (x[0] + x[1] + x[2])
//
//     # Initial equations
//     outputs['init_eq[0]'] = x[0] - 0.0
//     outputs['init_eq[1]'] = x[1] - 0.0
//     outputs['init_eq[2]'] = x[2] - 0.0
//     outputs['init_eq[3]'] = z[0] - 0.0
//     outputs['init_eq[4]'] = z[1] - 0.0
//     outputs['init_eq[5]'] = z[2] - 0.0
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: Initial conditions
// import numpy as np
// x = np.array([0.0, 0.0, 0.0])
// z = np.array([0.0, 0.0, 0.0])
// alpha = 0.5
// y = 0.0
// der_x = np.array([-alpha * x[i] for i in range(3)])
// der_z = np.array([z[i] + x[i] for i in range(3)])
// {
//   "x": x,
//   "z": z,
//   "y": np.array(y),
//   "alpha": np.array(alpha),
//   "der('x')": der_x,
//   "der('z')": der_z
// }
//
// @onnx-test-case
// # Test case 2: Non-zero state
// import numpy as np
// x = np.array([1.0, 2.0, 3.0])
// z = np.array([0.5, 1.0, 1.5])
// alpha = 0.5
// y = 6.0
// der_x = np.array([-alpha * x[i] for i in range(3)])
// der_z = np.array([z[i] + x[i] for i in range(3)])
// {
//   "x": x,
//   "z": z,
//   "y": np.array(y),
//   "alpha": np.array(alpha),
//   "der('x')": der_x,
//   "der('z')": der_z
// }
//
// @onnx-test-case
// # Test case 3: Different alpha
// import numpy as np
// x = np.array([0.5, 1.5, 2.5])
// z = np.array([1.0, 2.0, 3.0])
// alpha = 1.0
// y = 4.5
// der_x = np.array([-alpha * x[i] for i in range(3)])
// der_z = np.array([z[i] + x[i] for i in range(3)])
// {
//   "x": x,
//   "z": z,
//   "y": np.array(y),
//   "alpha": np.array(alpha),
//   "der('x')": der_x,
//   "der('z')": der_z
// }
//
