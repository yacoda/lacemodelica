//! base 0.1.0
package 'UnaryOps'
  model 'UnaryOps' "Unary plus and minus"
    Real 'x'(start = 1.0);
    Real 'y';
    Real 'z';
  equation
    der('x') = +0.5;
    'y' = -'x';
    'z' = -(('x' + 1.0) * 'y');
  end 'UnaryOps';
end 'UnaryOps';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs (already numpy scalars)
//     x = inputs['x']
//     der_x = inputs["der('x')"]
//     y = inputs['y']
//     z = inputs['z']
//
//     # Compute equation residuals
//     outputs['eq[0]'] = der_x - 0.5
//     outputs['eq[1]'] = y - (-x)
//     outputs['eq[2]'] = z - (-((x + 1.0) * y))
//
//     # Start value
//     outputs['start[0]'] = np.array(1.0)
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: Random value (seed 42)
// import numpy as np
// rng = np.random.RandomState(42)
// x = rng.uniform(-5.0, 5.0)
// der_x = 0.5
// y = -x
// z = -((x + 1.0) * y)
// {
//   "x": np.array(x),
//   "der('x')": np.array(der_x),
//   "y": np.array(y),
//   "z": np.array(z)
// }
//
// @onnx-test-case
// # Test case 2: Random value (seed 123)
// import numpy as np
// rng = np.random.RandomState(123)
// x = rng.uniform(-10.0, 10.0)
// der_x = 0.5
// y = -x
// z = -((x + 1.0) * y)
// {
//   "x": np.array(x),
//   "der('x')": np.array(der_x),
//   "y": np.array(y),
//   "z": np.array(z)
// }
//
// @onnx-test-case
// # Test case 3: Random value (seed 999)
// import numpy as np
// rng = np.random.RandomState(999)
// x = rng.uniform(-2.0, 2.0)
// der_x = 0.5
// y = -x
// z = -((x + 1.0) * y)
// {
//   "x": np.array(x),
//   "der('x')": np.array(der_x),
//   "y": np.array(y),
//   "z": np.array(z)
// }
