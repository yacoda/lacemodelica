// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Joris Gillis, YACODA

//! base 0.1.0
package 'AlgorithmIfStatement'
  // Function that returns the absolute value using if-statement
  pure function 'myAbs' "Absolute value using if-statement"
    input Real 'x';
    output Real 'result';
  algorithm
    if 'x' >= 0 then
      'result' := 'x';
    else
      'result' := -'x';
    end if;
  end 'myAbs';

  // Function that returns sign of a number (-1, 0, or 1)
  pure function 'mySign' "Sign function using if-elseif-else"
    input Real 'x';
    output Real 'result';
  algorithm
    if 'x' > 0 then
      'result' := 1;
    elseif 'x' < 0 then
      'result' := -1;
    else
      'result' := 0;
    end if;
  end 'mySign';

  // Function with if-statement that only has a then branch (no else)
  pure function 'clampPositive' "Clamp negative values to zero"
    input Real 'x';
    output Real 'result';
  algorithm
    'result' := 'x';
    if 'x' < 0 then
      'result' := 0;
    end if;
  end 'clampPositive';

  model 'AlgorithmIfStatement' "Model using functions with if-statements"
    Real 'x'(start = 1.0);
    Real 'absX';
    Real 'signX';
    Real 'clampedX';
  equation
    der('x') = -0.5;
    'absX' = 'myAbs'('x');
    'signX' = 'mySign'('x');
    'clampedX' = 'clampPositive'('x');
  end 'AlgorithmIfStatement';
end 'AlgorithmIfStatement';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs
//     x = inputs['x']
//     der_x = inputs["der(x)"]
//     absX = inputs['absX']
//     signX = inputs['signX']
//     clampedX = inputs['clampedX']
//
//     # Equation 0: der(x) = -0.5
//     outputs['eq[0]'] = der_x - (-0.5)
//
//     # Equation 1: absX = myAbs(x)
//     outputs['eq[1]'] = absX - np.abs(x)
//
//     # Equation 2: signX = mySign(x)
//     outputs['eq[2]'] = signX - np.sign(x)
//
//     # Equation 3: clampedX = clampPositive(x)
//     outputs['eq[3]'] = clampedX - np.maximum(x, 0)
//
//     # Initial value
//     outputs['start[0]'] = np.array(1.0)
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: positive x = 5.0
// import numpy as np
// x = 5.0
// der_x = -0.5
// absX = 5.0
// signX = 1.0
// clampedX = 5.0
// {
//   "x": np.array(x),
//   "der(x)": np.array(der_x),
//   "absX": np.array(absX),
//   "signX": np.array(signX),
//   "clampedX": np.array(clampedX)
// }
//
// @onnx-test-case
// # Test case 2: negative x = -3.0
// import numpy as np
// x = -3.0
// der_x = -0.5
// absX = 3.0
// signX = -1.0
// clampedX = 0.0
// {
//   "x": np.array(x),
//   "der(x)": np.array(der_x),
//   "absX": np.array(absX),
//   "signX": np.array(signX),
//   "clampedX": np.array(clampedX)
// }
//
// @onnx-test-case
// # Test case 3: zero x = 0.0
// import numpy as np
// x = 0.0
// der_x = -0.5
// absX = 0.0
// signX = 0.0
// clampedX = 0.0
// {
//   "x": np.array(x),
//   "der(x)": np.array(der_x),
//   "absX": np.array(absX),
//   "signX": np.array(signX),
//   "clampedX": np.array(clampedX)
// }
//
