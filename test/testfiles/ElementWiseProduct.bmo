// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Joris Gillis, YACODA

//! base 0.1.0
package 'ElementWiseProduct'
  model 'ElementWiseProduct' "Test model with element-wise product"
    parameter Real 'alpha' = 0.5 "Decay coefficient";

    Real 'A'[3, 4](fixed = true, start = 1.0) "First matrix";
    Real 'B'[3, 4](fixed = true, start = 2.0) "Second matrix";
    Real 'C'[3, 4] "Element-wise product";
    Real 'y' "Output";

  equation
    der('A') = -'alpha' * 'A';
    der('B') = -0.1 * 'B';
    'C' = 'A' .* 'B';
    'y' = 'C'[1, 1] + 'C'[2, 2] + 'C'[3, 3];

  end 'ElementWiseProduct';
end 'ElementWiseProduct';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs (already numpy arrays)
//     alpha = inputs['alpha']
//     A = inputs['A']  # 3x4 matrix
//     B = inputs['B']  # 3x4 matrix
//     C = inputs['C']  # 3x4 matrix
//     der_A = inputs["der(A)"]  # 3x4 matrix
//     der_B = inputs["der(B)"]  # 3x4 matrix
//     y = inputs['y']  # scalar
//
//     # Equation 0: der(A) = -alpha * A => der(A) + alpha * A = 0
//     outputs['eq[0]'] = der_A + alpha * A
//
//     # Equation 1: der(B) = -0.1 * B => der(B) + 0.1 * B = 0
//     outputs['eq[1]'] = der_B + 0.1 * B
//
//     # Equation 2: C = A .* B => C - A .* B = 0
//     outputs['eq[2]'] = C - A * B
//
//     # Equation 3: y = C[1,1] + C[2,2] + C[3,3] => y - (C[1,1] + C[2,2] + C[3,3]) = 0
//     # Note: Modelica uses 1-based indexing, Python uses 0-based
//     diagonal_sum = C[0, 0] + C[1, 1] + C[2, 2]
//     outputs['eq[3]'] = y - diagonal_sum
//
//     # Initial values (start attributes)
//     outputs['start[0]'] = np.full((3, 4), 1.0)  # A's initial value
//     outputs['start[1]'] = np.full((3, 4), 2.0)  # B's initial value
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: Random matrices (seed 42)
// import numpy as np
// rng = np.random.RandomState(42)
// alpha = 0.5
// A = rng.uniform(0.5, 1.5, (3, 4))
// B = rng.uniform(1.5, 2.5, (3, 4))
// C = A * B
// y = C[0, 0] + C[1, 1] + C[2, 2]
// der_A = -alpha * A
// der_B = -0.1 * B
// {
//   "alpha": np.array(0.5),
//   "A": A,
//   "B": B,
//   "C": C,
//   "y": np.array(y),
//   "der(A)": der_A,
//   "der(B)": der_B
// }
//
// @onnx-test-case
// # Test case 2: Random matrices (seed 123)
// import numpy as np
// rng = np.random.RandomState(123)
// alpha = 0.5
// A = rng.uniform(0.1, 1.0, (3, 4))
// B = rng.uniform(1.0, 3.0, (3, 4))
// C = A * B
// y = C[0, 0] + C[1, 1] + C[2, 2]
// der_A = -alpha * A
// der_B = -0.1 * B
// {
//   "alpha": np.array(0.5),
//   "A": A,
//   "B": B,
//   "C": C,
//   "y": np.array(y),
//   "der(A)": der_A,
//   "der(B)": der_B
// }
//
// @onnx-test-case
// # Test case 3: Random matrices (seed 999)
// import numpy as np
// rng = np.random.RandomState(999)
// alpha = 0.5
// A = rng.uniform(-1.0, 1.0, (3, 4))
// B = rng.uniform(-2.0, 2.0, (3, 4))
// C = A * B
// y = C[0, 0] + C[1, 1] + C[2, 2]
// der_A = -alpha * A
// der_B = -0.1 * B
// {
//   "alpha": np.array(0.5),
//   "A": A,
//   "B": B,
//   "C": C,
//   "y": np.array(y),
//   "der(A)": der_A,
//   "der(B)": der_B
// }
