// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Joris Gillis, YACODA

//! base 0.1.0
package 'AlgorithmWhileLoop'
  // Function with a while loop that counts iterations until threshold
  pure function 'countToThreshold' "Count how many steps to exceed threshold"
    input Real 'threshold';
    input Real 'step';
    output Real 'count';
    output Real 'total';
  algorithm
    'count' := 0.0;
    'total' := 0.0;
    while 'total' < 'threshold' loop
      'total' := 'total' + 'step';
      'count' := 'count' + 1.0;
    end while;
  end 'countToThreshold';

  model 'AlgorithmWhileLoop' "Model using function with while loop"
    parameter Real 'threshold' = 10.0;
    parameter Real 'step' = 3.0;
    Real 'x'(start = 0.0);
    Real 'iterations';
    Real 'finalValue';
  equation
    der('x') = 0.1;
    ('iterations', 'finalValue') = 'countToThreshold'('threshold', 'step');
  end 'AlgorithmWhileLoop';
end 'AlgorithmWhileLoop';

// @onnx-test-reference
// Python reference implementation for ONNX runtime testing
// def reference_implementation(inputs):
//     import numpy as np
//     outputs = {}
//
//     # Extract inputs
//     x = inputs['x']
//     der_x = inputs["der(x)"]
//     threshold = inputs['threshold']
//     step = inputs['step']
//     iterations = inputs['iterations']
//     finalValue = inputs['finalValue']
//
//     # Equation 0: der(x) = 0.1
//     outputs['eq[0]'] = der_x - 0.1
//
//     # Equation 1-2: (iterations, finalValue) = countToThreshold(threshold, step)
//     count = 0.0
//     acc = 0.0
//     while acc < threshold:
//         acc = acc + step
//         count = count + 1.0
//     expected_iterations = count
//     expected_total = acc
//     outputs['eq[1]'] = iterations - expected_iterations
//     outputs['eq[2]'] = finalValue - expected_total
//
//     # Initial value
//     outputs['start[0]'] = np.array(0.0)
//
//     return outputs
//
// @onnx-test-case
// # Test case 1: threshold=10, step=3 -> 4 iterations, total=12
// import numpy as np
// x = 0.0
// der_x = 0.1
// threshold = 10.0
// step = 3.0
// iterations = 4.0  # 0+3=3, 3+3=6, 6+3=9, 9+3=12 >= 10
// finalValue = 12.0
// {
//   "x": np.array(x),
//   "der(x)": np.array(der_x),
//   "threshold": np.array(threshold),
//   "step": np.array(step),
//   "iterations": np.array(iterations),
//   "finalValue": np.array(finalValue)
// }
//
// @onnx-test-case
// # Test case 2: threshold=5, step=2 -> 3 iterations, total=6
// import numpy as np
// x = 1.0
// der_x = 0.1
// threshold = 5.0
// step = 2.0
// iterations = 3.0  # 0+2=2, 2+2=4, 4+2=6 >= 5
// finalValue = 6.0
// {
//   "x": np.array(x),
//   "der(x)": np.array(der_x),
//   "threshold": np.array(threshold),
//   "step": np.array(step),
//   "iterations": np.array(iterations),
//   "finalValue": np.array(finalValue)
// }
//
// @onnx-test-case
// # Test case 3: threshold=1, step=0.5 -> 2 iterations, total=1.0
// import numpy as np
// x = 2.0
// der_x = 0.1
// threshold = 1.0
// step = 0.5
// iterations = 2.0  # 0+0.5=0.5, 0.5+0.5=1.0 >= 1.0
// finalValue = 1.0
// {
//   "x": np.array(x),
//   "der(x)": np.array(der_x),
//   "threshold": np.array(threshold),
//   "step": np.array(step),
//   "iterations": np.array(iterations),
//   "finalValue": np.array(finalValue)
// }
//
